// compile-x64.cpp.dasc - Compile bytecode to native amd64 code
// This is a DynASM file. Must be run through DynASM to produce a C++ file

// Further reading
// Agner Fog, Calling Conventions
// http://www.agner.org/optimize/calling_conventions.pdf

// TODO: Exception checking

// TODO: Function application
// TODO: Constants
// TODO: Type checking
// TODO: Conditionals

// TODO: Cannot return a Value on Windows (!!!)
// Calling a Value-returning function causes the program to crash, seemingly under any
// circumstance

// We also may need to deal with exceptions. Although we don't use them, we want to handle
// user code correctly

// TODO: Unclear on what the ideal way to call C++ functions is. There does not appear to be a 
// trivial way to call methods on the arete::State instance

// Anatomy of a natively-compiled Scheme function

// Registers:
// r12 = pointer to arete::State*
// r13 = during execution, stores stack index.
// after control ends (due to exception or return), stores return value

// Stack:
// 0-8 = pointer to previous native stack frame (if any)
// 8-16 = count of gc'd values
// 16-a = computation stack
// a-b = local values
// b-c = upvalues

// TODO: Use offsetof and other stuff instead of calling functions to retrieve information
// about a particular State

// TODO Write an error handling function
// Probably

// TODO Figure out how to print a string

#include "arete.hpp"

#include "dasm_proto.h"
#include "dasm_x86.h"

#define AR_LOG_JIT(msg) ARETE_LOG((ARETE_LOG_TAG_JIT), "jit", msg)

namespace arete {

static size_t invocation = 0;
ptrdiff_t print_int(State& state, ptrdiff_t i) {
  std::cout << "print_int(" << invocation++ << "):" << i << std::endl;
  return 0;
}

void print_int_simple(ptrdiff_t i) {
  std::cout << "print_int_simple(" << invocation++ << "):" << i << std::endl;
}

void debug_middle(ptrdiff_t idx, ptrdiff_t i) {
  switch(idx) { 
    case 0: std::cout << "constant ptr: " << i << std::endl;
  }


}

void print_2int_simple(ptrdiff_t a, ptrdiff_t b) {
  std::cout << "print_2int:" << a << ' ' << b << std::endl;
}

void print_something() {
  std::cout << "something" << std::endl;
}

Value state_make_pair(State* state) {
  Value pare(state->make_pair(C_FALSE, C_FALSE));
  std::cout << "state_make_pair returning " << (size_t) pare.bits << std::endl;
  return pare;
}

void state_collect(State* state) {
  std::cout << "COLLECTION BEGINNING " << (ptrdiff_t) state << std::endl;

  state->gc.collect();

  std::cout << "COLLECTION RETURNING" << std::endl;
}

static ptrdiff_t rsp = 0;

Value return_true() {
	return C_TRUE;
}

Value return_true_state(State* state) {
	std::cout << "Return_true called with state " << (ptrdiff_t) state << std::endl;
	return C_TRUE;
}

void return_true_param(ptrdiff_t* thing) {
	(*thing) = 2;
}

ptrdiff_t return_true_int() {
	return 2;
}

void sanity_log_1(ptrdiff_t rsp_) {
  rsp = rsp_;
  std::cout << "sanity_log_1: rsp after stack allocation: " << rsp << std::endl;
}

void sanity_log_2(ptrdiff_t compstack) {
  std::cout << "sanity_log_2: location of computation stack[0]: " << compstack << "(" << (rsp - compstack) << " from rsp)" << std::endl;
}

// Exception tag codes
enum {
  E_TYPE
};

// Exception source codes
enum {
  E_FX_ADD
};

// Exception message codes
enum {
  E_EXPECTED_FIXNUM_1,
  E_EXPECTED_FIXNUM_2
};

void native_exception2(State* state, unsigned tag, unsigned src, unsigned code ) {
  AR_LOG_JIT("native_exception2 called " << (ptrdiff_t) state << " with arguments " << tag << " " << src << " " << code);//<< " with arguments " << tag << " " << src << " " << code);
}


Value native_exception(State* state, unsigned tag, unsigned src, unsigned code) {
  AR_LOG_JIT("native_exception called " << (ptrdiff_t) state << " with arguments " << tag << " " << src << " " << code);
  std::ostringstream os;

  Value tag_s;
  if(tag_s == E_TYPE) {
    tag_s = state->globals[State::S_TYPE_ERROR];
  } else {
    tag_s = state->globals[State::S_EVAL_ERROR];
  }

  switch(src) {
    case E_FX_ADD: {
      os << "primitive fx+ ";
      break;
    }
    default: break;
  }

  switch(code) {
    case E_EXPECTED_FIXNUM_1: os << "expected argument 1 to be a fixnum"; break;
    case E_EXPECTED_FIXNUM_2: os << "expected argument 2 to be a fixnum"; break;
  }

  return state->make_exception(tag_s, os.str(), C_FALSE);
}

void state_simple(State* state) {

}

void state_push_native_gc_frame(State* state, NativeFrame* frame) {
	void* thing;
	std::cout << (ptrdiff_t) &thing << std::endl;

  //std::cout << "ptr to current_state " << (ptrdiff_t) current_state << std::endl;
  std::cout << "ptr to state " << (ptrdiff_t) state << std::endl;
  std::cout << "ptr to native frame " << (ptrdiff_t) frame << std::endl;
  std::cout << "native frame value_count " << (ptrdiff_t) frame->value_count << std::endl;
  std::cout << "ptr to previous native frame " << (ptrdiff_t) frame->previous << std::endl;
  state->gc.native_frames = frame;

  //return C_UNSPECIFIED;
}

ptrdiff_t return_int(ptrdiff_t a) {
	// TODO: Returning a Value from a function causes issues on windows
	return a;
}

void state_pop_native_gc_frame(State* state) {
	std::cout << "popping gc frame " << (ptrdiff_t) state->gc.native_frames << std::endl;
  state->gc.native_frames = state->gc.native_frames->previous;
}

ptrdiff_t state_gc_frame(State* state) {
  std::cout << "state_gc_frame" << (ptrdiff_t) state->gc.native_frames << std::endl;

  return (ptrdiff_t)state->gc.native_frames;

};

// callee-save

// parameters = rdi, rsi, rdx, rcx, r8, r9, xmm0-7
// rsp = stack pointer
// saved = rbx, rbp, rdi, rsi, rsp, r12-15
// rsp-128 is the red zone; can be used for temp values but destroyed by any called function

Value vmfunction_to_native(State& state, size_t argc, Value* argv) {
  const char* fn_name = "vmfunction->native";
  AR_FN_EXPECT_TYPE(state, argv, 0, VMFUNCTION);
  Value bv, nfn, vfn;

  vfn = argv[0];

  AR_LOG_JIT("vmfunction_to_native called");

  VMFunction* vmf = vfn.as_unsafe<VMFunction>();

  unsigned local_count = vmf->local_count;
  unsigned stack_max = vmf->stack_max;
  unsigned label = 0;

  // Using the otherwise not-used-in-this codebase kBlah style to denote things that will become
  // constants in the compiled code

  unsigned total_stack = local_count+stack_max;
  unsigned kFrameSize = local_count + stack_max + 1;
  unsigned kTotalStackSize = sizeof(NativeFrame) - sizeof(void*) + ((total_stack) * sizeof(void*));
  size_t kValueSize = sizeof(void*);
  unsigned kCompStackOffset = 24; //kTotalStackSize - (kValueSize * stack_max);
  unsigned kTotalStackSizeAligned = kTotalStackSize;

	std::cout << kTotalStackSizeAligned << std::endl;
  if(((kTotalStackSizeAligned + 56) % 16) != 0) {
    kTotalStackSizeAligned += 8;
		std::cout << kTotalStackSizeAligned << std::endl;
  }

  //AR_ASSERT(((kTotalStackSizeAligned + 56) % 16) == 0);

  AR_LOG_JIT("function frame info. stack_max " << stack_max << " kTotalStackSize " << kTotalStackSize << \
    " kTotalStackSizeAligned " << kTotalStackSizeAligned << " kCompStackOffset " << kCompStackOffset \
		<< " kFrameSize " << kFrameSize);

  // A note on a possible source of confusion: in the virtual machine, the stack is a separately
  // allocated data structure from locals and upvalues. Thus there's the computation stack which
  // exists only metaphorically here and is where the values of temporary computation are stored and
  // tracked by the garbage collector, and the actual stack i.e. rsp.

  | .arch x64
  |.section code

  |.define rState, r12
  |.define rStackI, r13
  |.define rFx, r15
	|.if WINDOWS
	| .define rArg1, rcx
	| .define rArg2, rdx
  | .define rArg3, r8
  | .define rArg4, r9
	|.else
  | .define rArg1, rdi
  | .define rArg2, rsi
  | .define rArg3, rdx
  | .define rArg4, rcx
  | .define rArg5, r8
	|.endif
  |.type state, State, rState


  |.macro simpCall, fun
	| .if WINDOWS
	| push rbp; mov rbp, rsp; mov64 rax, (ptrdiff_t) fun; call rax; mov rsp, rbp; pop rbp
	| .else
  | push rbp; push rsp; mov64 rax, (ptrdiff_t) fun; call rax; pop rsp; pop rbp;
	| .endif
  |.endmacro

	// On Windows, a Value is returned as a pointer to a stack value. Can't find
	// documentation for this anywhere, but both Clang and MSVC do it; which
	// means a little dance is needed to get it into rax.
	|.macro stateCallRetValue, method
  | .if WINDOWS
  |  push rbp
  |  mov rbp, rsp
  |  mov rArg1, rState
  |  mov64 rax, (ptrdiff_t) method
	|  sub rsp, 32
  |  call rax
	|  add rsp, 32
	|  mov rArg1, [rax]
	|  mov rax, rArg1
	|  mov rsp, rbp
  |  pop rbp
  | .else
  |  push rbp
  |  push rsp
  |  mov rArg1, rState
  |  mov64 rax, (ptrdiff_t) method
  |  call rax
  |  pop rsp
  |  pop rbp
  | .endif
	|.endmacro

  |.macro stateCall, method
  | .if WINDOWS
  |  push rbp
  |  mov rbp, rsp
  |  mov rArg1, rState
  |  mov64 rax, (ptrdiff_t) method
	|  sub rsp, 32
  |  call rax
	|  add rsp, 32
	|  mov rsp, rbp
  |  pop rbp
  | .else
  |  push rbp
  |  push rsp
  |  mov rArg1, rState
  |  mov64 rax, (ptrdiff_t) method
  |  call rax
  |  pop rsp
  |  pop rbp
  | .endif
  |.endmacro

  // Check that value in STORE is a valid fixnum, if not, generate a type error with SRC and CODE
  // Generates a label
  |.macro checkFixnumP, store, src, code
  | mov rax, store
  | and rax, 1
  | cmp rax, 1
  | jz >1
  // Test failed. Set up registers for exception
	| mov rArg2, E_TYPE;
	| mov rArg3, src; mov rArg4, code;
  | jmp ->exception
  |1:
  |.endmacro

  // takes rStackI and sets STORE to the rsp offset it needs
  |.macro getCompStackIndex, store
  | mov store, rStackI
  | imul store, kValueSize
  | add store, kCompStackOffset
  | add store, rsp
  |.endmacro

  |.macro getCompStackTopValue, store
  | getCompStackIndex store
  | mov store, [store]
  |.endmacro


  // Put a pointer to stack[I] in STORE
  |.macro getCompStackIndexAt, i, store
  | mov store, i
  | imul store, kValueSize
  | add store, kCompStackOffset
  | add store, rsp
  |.endmacro

  dasm_State *d;
  dasm_init(&d, DASM_MAXSECTION);

  |.actionlist actions
  |.globals globals
  |.globalnames globalnames

  void* globals[globals_MAX == 0 ? 1 : globals_MAX];
  (void) globalnames; // suppress compiler warning

  dasm_setupglobal(&d, globals, globals_MAX);
  dasm_setup(&d, actions);

  dasm_State** Dst = &d;

  |.code

  // Prologue
  // Save registers
	| push rbp
  | mov rbp, rsp
  | push rbx
  | push rState
  | mov rState, rArg1
  | push rArg1
  | push rArg2
  | push rStackI
  | push rFx

  // NOTE: At the boundary of any CALL, stack size must be a multiple of 16!
  // PUSHing grows it by only 8.

  // Currently we push 7 * 8 = 56 at the start
  // This means that 56 + kTotalStackSizeAligned must be a multiple of 16 somehow

  // But not on Windows?

  | mov rStackI, 0

  // Allocate stack space
  | sub rsp, kTotalStackSizeAligned

  // NativeFrame::previous
  | mov qword [rsp+0], 0
  // NativeFrame::value_count
  | mov qword [rsp+8], kFrameSize
  // NativeFrame::values[0] = argument 2
  | mov qword [rsp+16], rArg2
	| mov qword [rsp+24], 0

  | mov rArg1, rsp
  | simpCall sanity_log_1

  | getCompStackIndex rArg1
  | simpCall sanity_log_1

  // Zero out GC frame
  // Assumes function has a stack size of at least one.

  // rArg2 = loop limit, kFrameSize + rsp
  | mov rArg2, rsp
  | add rArg2, ((kFrameSize*8)+8)

  // Set rArg1 to NativeFrame::values[0]
  | mov rArg1, rsp
  | add rArg1, 16

  |->gc_zero:
  // Now add 8 to rArg1 at top of loop so it points at NativeFrame::values[0]
  | add rArg1, 8
  // Set value to zero
  | mov qword [rArg1], 0
  | cmp rArg1, rArg2
  | jne ->gc_zero

  // Initialize locals

  | mov rArg2, rsp; 
	|  stateCall state_push_native_gc_frame;
	|  stateCall state_collect;

  // Execute function body
  size_t code_offset = 0;
  size_t *code = vmf->code_pointer();
  bool done = false;

  while(!done) {
    // Generate labels here

    switch(code[code_offset++]) {
      case OP_PUSH_IMMEDIATE: {
        size_t value = code[code_offset++];
        AR_LOG_JIT("push-immediate " << Value(value) << " (" << (ptrdiff_t) value << ")");
        // Retrieve location of stack value
        | getCompStackIndex rArg1
        // Set value
        | mov qword [rArg1], (size_t) value
        // Increment stack
        | inc rStackI
        break;
      }

      case OP_PUSH_CONSTANT: {
        size_t idx = code[code_offset++];
        AR_LOG_JIT("push-constant " << idx);

        // Retrieve constants array by 
        // Get function pointer
        | mov rArg2, [rsp+16]
        | stateCall print_int
        | mov rArg2, [rsp+16]
        // Get &VMFunction::constants
        | add rArg2, (ptrdiff_t)(&((VMFunction*)0)->constants)
        // Get &VMFunction->constants->data[idx]
        | mov rArg2, [rArg2]
        | add rArg2, (ptrdiff_t)((((ptrdiff_t)&((VectorStorage*)0)->data)) + (idx * 8))

        // Get VMFunction->constants->data[idx]
        | mov rArg2, [rArg2]


        | push rArg1; push rArg2; mov rArg1, 0; simpCall debug_middle; pop rArg2; pop rArg1;

        /*
        // Add to top of stack
        // Get VMFunction->constants->data[idx]
        | mov rArg2, [rArg2]
        */

        | getCompStackIndex rArg1
        | mov [rArg1], rArg2
        //| mov qword [rArg1], 821

        | inc rStackI
        | stateCall state_collect
        break;
      }

      case OP_FX_ADD: {
        | getCompStackIndex rArg2
        AR_LOG_JIT("fx+");
        | sub rArg2, 8

        // 2 labels: two for each type test
        | checkFixnumP [rArg2], E_FX_ADD, E_EXPECTED_FIXNUM_2

        // Extract fixnum argument 1 value
        | shr qword [rArg2], 1

        | getCompStackIndex rArg1
        | sub rArg1, 16
        | checkFixnumP [rArg1], E_FX_ADD, E_EXPECTED_FIXNUM_1
        // extract fixnum argument 2 value
        | shr qword [rArg1], 1

        //| push rax; push rArg1; push rArg2; mov rArg2, [rArg1]; mov64 rax, (size_t) print_int; call rax; pop rArg2; pop rArg1; pop rax;
        //| push rax; push rArg1; push rArg2; mov rArg2, [rArg2]; mov64 rax, (size_t) print_int; call rax; pop rArg2; pop rArg1; pop rax;

        | mov rax, [rArg1]
        //| push rax; push rArg1; push rArg2; mov rArg2, rax; mov64 rax, (size_t) print_int; call rax; pop rArg2; pop rArg1; pop rax;
        | add rax, [rArg2]
        //| push rax; push rArg1; push rArg2; mov rArg2, rax; mov64 rax, (size_t) print_int; call rax; pop rArg2; pop rArg1; pop rax;

        | shl rax, 1
        | inc rax
        | push rax; push rArg1; push rArg2; mov rArg2, rax; mov64 rax, (size_t) print_int; call rax; pop rArg2; pop rArg1; pop rax;

        | mov [rArg1], rax
        | dec rStackI
        break;
      }

      case OP_RETURN:
      case OP_RETURN_END: {
        AR_LOG_JIT("return");
        //| getCompStackTop rax
        //| mov rArg2, [rsp+16]
        //| mov rArg2, rax
        //| stateCall print_int
        //| sub rStackI, 1

        | sub rStackI, 1
        | getCompStackIndex rArg1
        | mov rStackI, [rArg1]
        | jmp ->unwind

        if(code[code_offset-1] == OP_RETURN_END)
          done = true;

        break;
      }

      default: {
        return state.eval_error("unknown bytecode");
      }
    }
  }
  done:

  | stateCall state_pop_native_gc_frame

  | jmp ->unwind
  |->exception:

	//| mov rArg2, 123; mov rArg3, 456; mov rArg4, 789;
	| stateCallRetValue native_exception
	//| mov rStackI, rax
	| mov rStackI, rax
	//| mov rax, 0

  |->unwind:
	//
  // Free stack space
  | add rsp, kTotalStackSizeAligned

  // Retrieve return value from rStackI
  | mov rax, rStackI

  // Restore registers
  | pop rFx
  | pop rStackI
  | pop rArg2
  | pop rArg1
	| pop rState
  | pop rbx
  | mov rsp, rbp
	| pop rbp

  // Create return value

#if 0
	| push rbp
	| mov rbp, rsp
	| push rbx
	| push rState
	| mov rState, rArg1
	| push rArg1; push rArg2;
	| push rStackI; push rFx;

  | sub rsp, kTotalStackSizeAligned

  // NativeFrame::previous
  | mov qword [rsp+0], 0
  // NativeFrame::value_count
  | mov qword [rsp+8], kFrameSize
  // NativeFrame::values[0] = argument 2
  | mov qword [rsp+16], rArg2

  // Zero out GC frame
  // Assumes function has a stack size of at least one.

  // rArg2 = loop limit, kFrameSize + rsp
  | mov rArg2, rsp
  | add rArg2, ((kFrameSize*8)+8)

  // Set rArg1 to NativeFrame::values[0]
  | mov rArg1, rsp
  | add rArg1, 16

  |->gc_zero:
  // Now add 8 to rArg1 at top of loop so it points at NativeFrame::values[0]
  | add rArg1, 8
  // Set value to zero
  | mov qword [rArg1], 0
  | cmp rArg1, rArg2
  | jne ->gc_zero

  | mov rArg1, rsp
  | simpCall sanity_log_1

  | getCompStackIndex rArg1
  | simpCall sanity_log_2

	| simpCall print_something
	| mov rax, 0

  | mov rArg2, rsp; stateCall state_push_native_gc_frame

	| sub rsp, 32
  | stateCall state_collect
	| add rsp, 32
	| mov rax, 0

	| add rsp, kTotalStackSizeAligned

	| pop rFx; pop rStackI;
	| pop rArg2; pop rArg1;
	| pop rState
	| pop rbx
	| mov rsp, rbp
	| pop rbp
#endif 

  | ret

  size_t size;

  dasm_link(&d, &size);

  AR_FRAME(state, bv, nfn);

  bv = state.make_bytevector<unsigned char>(size);

  dasm_encode(&d, bv.bv_data());

  dasm_free(&d);

  AR_LOG_JIT("vmfunction->native done; calling function");

  ptrdiff_t (*ptr)(State*, size_t, size_t) = (ptrdiff_t (*)(State*, size_t, size_t)) bv.bv_data();

  std::cout << "VMFunction ptr: " << (ptrdiff_t)vfn.bits << std::endl;
  std::cout << "Constants ref: " << (ptrdiff_t)&vfn.as<VMFunction>()->constants << std::endl;
  std::cout << "Constants ptr: " << (ptrdiff_t)vfn.as<VMFunction>()->constants << std::endl;
  std::cout << "Constants ptr[0]: " << (ptrdiff_t)&vfn.as<VMFunction>()->constants->data[0] << std::endl;

  std::cout << "#(";
  for(size_t i = 0; i != vfn.as<VMFunction>()->constants->length; i++) {
    std::cout << (ptrdiff_t)vfn.as<VMFunction>()->constants->data[i].bits;
    std::cout << ' ';
  }
  std::cout << ')' << std::endl;
	std::cout << "Calling against state: " << (ptrdiff_t) &state << std::endl;
  ptrdiff_t result = ptr(&state, (size_t)vfn.bits, 0);

  std::cout << "result int: " << (result) << std::endl;
  std::cout << "result: " << Value(result) << std::endl;

  return C_UNSPECIFIED;
}

AR_DEFUN("vmfunction->native", vmfunction_to_native, 1);

}
