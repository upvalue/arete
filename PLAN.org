* Refactoring
  - [ ] Method calling conventions revamp.
    Right now, we use argc/argv style, which is convenient for the VM design but probably problematic from a performance
    standpoint and is awkward to use from C++.

* Language
  - [ ] Gradual typing
  - [ ] SRFI 89: Optional arguments

* Interpreter
  - [ ] Tail-call optimization.
    This may not be a big deal, but I've had to bump the stack size manually on Emscripten/Windows builds because it's
    so stack hungry. (AR_FRAME may also be a part of this as much as the lack of TCO). It might be simpler to just
    include a precompiled bytecode image for most use cases.
  - [ ] Lookup cache
    Might help.

* Memory management
  - [ ] Symbol collection
  - [ ] Generational garbage collection

* Reader/syntax
  - [ ] Table/struct literals

* Runtime
  - [ ] Image saving: Images rely on C++ static initialization order to restore pointers to C++ functions. This may
    not be very portable at all.

* Compiler
  - [ ] Analysis pass.
    Replace symbol usage with unique eq? based "bindings." Display closures and most basic inlining,
    e.g. car in the application position.
  - [ ] Native code compilation

* I/O
  - [ ] Tables and structs should have read/write support
    Structs and other high-level objects may not be READ by any Arete instance, depending on code being loaded, but
    it'd still be good to have.

* Emscripten compile
  - [ ] Better demo. REPL, SDL, etc. Probably will need to write a callable C interface.

* Various optimizations that probably won't make a difference
  - [x] heap_type_equals() primitive, for when we want to check whether the type of a heap object matches a type.
