* Refactoring
  - [ ] Method calling conventions revamp?
    Right now, we use argc/argv style, which is convenient for the VM design but probably problematic from a performance
    standpoint and is awkward to use from C++.

* Utilities
  - [ ] A pattern matcher
  - [ ] A less tedious way of writing macros
    Here's a thought: a reader macro for renames.
    #`(let ((#,injection hello) (var #f)) (cons #,injection var))
    this turns into a quasiquote with all symbols NOT inside unquotes

* Language
  - [ ] Gradual typing
  - [x] Delimited continuations

    Shift/reset. We'd need to replace is_active_exception with something that
    can communicate return values to a SHIFT point.

* RNRS & SRFIs
  - [ ] Syntax-rules
  - [x] map & for-each must accept multiple lists as arguments
  - [ ] SRFI 89: Optional arguments

* Expander
  - [ ] Chez Scheme identifier-syntax

* Interpreter
  - [x] Tail-call optimization.
    This may not be a big deal, but I've had to bump the stack size manually on Emscripten/Windows builds because it's
    so stack hungry. (AR_FRAME may also be a part of this as much as the lack of TCO). It might be simpler to just
    include a precompiled bytecode image for most use cases.
  - [ ] Lookup cache
    Might help.

* Virtual machine
  - We can't run things like the R7RS ack benchmark because of all the recursion it causes.
    Arete's VM is definitely very stack hungry, it has no intelligent way of growing the stack.
    I tried simply failing to malloc when a certain recursion limit is reached, but that still
    doesn't do enough, presumably because VMFrame itself and perhaps the various AR_FRAMEs mean
    it uses a lot of stack space.

    Not sure how important it is in practice; the R7RS ack benchmark results in something like
    300000 non-tail recursive calls, for reference, Python's default limit is 1000.

* Jettison interpreter
  we have kind of a rickety bootstrap where we have to (a) write the expander in a primitive version of the language
  because things like LET aren't available and (b) recompiling the whole system in-place is rather complex.
  
  However, this does allow us to rapidly and easily change the language. We'd
  probably need better facilities for cross-platform serialization of the
  heap (or compiling single files to FASLs) before we do this.

* Memory management
  - [ ] Symbol collection
  - [ ] Generational garbage collection

* Reader/syntax
  - [ ] Table/struct literals

* Runtime
  - [ ] Make certain strings immutable. We're using them as hash table keys, those should never be mutated.
  - [ ] Image saving: Images rely on C++ static initialization order to restore pointers to C++ functions. This may
    not be very portable at all.
  - [ ] Image saving should include source code, or it should be somehow lazily loaded on errors.
  - [ ] Better hash table implementation and benchmarks

* Compiler
  - [ ] Analysis pass.
    Replace symbol usage with unique eq? based "bindings." Display closures and most basic inlining,
    e.g. car in the application position.
  - [ ] Native code compilation

* I/O
  - [ ] Tables and structs should have read/write support
    Structs and other high-level objects may not be READ by any Arete instance, depending on code being loaded, but
    it'd still be good to have.

* Emscripten compile
  - [ ] Better demo. REPL, SDL, etc. Probably will need to write a callable C interface.

* Various optimizations that probably won't make a difference
  - [x] heap_type_equals() primitive, for when we want to check whether the type of a heap object matches a type.

  - [ ] We could collapse CFunctions and VMFunctions most likely, and remove indirections from the process of function
    application. Specifically, all CFunctions could take a closure argument which would be C_FALSE by default. We could
    even combine Closure and VMFunction at the cost of more memory usage. Otherwise, the only difference between
    apply_vm and CFunction is that apply_vm relies on rest arguments having already been created
    . But we could do that at the top of apply_vm

