* Refactoring
  - [ ] Method calling conventions revamp?
    Right now, we use argc/argv style, which is convenient for the VM design but probably problematic from a performance
    standpoint and is awkward to use from C++.

* Language
  - [ ] Gradual typing

* RNRS & SRFIs
  - [ ] Syntax-rules
  - [ ] map & for-each must accept multiple lists as arguments
  - [ ] SRFI 89: Optional arguments

* Interpreter
  - [x] Tail-call optimization.
    This may not be a big deal, but I've had to bump the stack size manually on Emscripten/Windows builds because it's
    so stack hungry. (AR_FRAME may also be a part of this as much as the lack of TCO). It might be simpler to just
    include a precompiled bytecode image for most use cases.
  - [ ] Lookup cache
    Might help.

* Virtual machine
  - We can't run things like the R7RS ack benchmark because of all the recursion it causes.
    Arete's VM is definitely very stack hungry, it has no intelligent way of growing the stack.
    I tried simply failing to malloc when a certain recursion limit is reached, but that still
    doesn't do enough, presumably because VMFrame itself and perhaps the various AR_FRAMEs mean
    it uses a lot of stack space.

    Not sure how important it is in practice; the R7RS ack benchmark results in something like
    300000 non-tail recursive calls, for reference, Python's default limit is 1000.

* Jettison interpreter
  we have kind of a rickety bootstrap where we have to (a) write the expander in a primitive version of the language
  because things like LET aren't available and (b) recompiling the whole system in-place is rather complex. However,
  this does allow us to rapidly and easily change the language. We'd probably need better facilities for cross-platform
  serialization of the heap (or compiling single files to FASLs) before we do this.

* Memory management
  - [ ] Symbol collection
  - [ ] Generational garbage collection

* Reader/syntax
  - [ ] Table/struct literals

* Runtime
  - [ ] Make certain strings immutable. We're using them as hash table keys, those should never be mutated.
  - [ ] Image saving: Images rely on C++ static initialization order to restore pointers to C++ functions. This may
    not be very portable at all.
  - [ ] Image saving should include source code, or it should be somehow lazily loaded on errors.
  - [ ] Better hash table implementation and benchmarks

* Compiler
  - [ ] Analysis pass.
    Replace symbol usage with unique eq? based "bindings." Display closures and most basic inlining,
    e.g. car in the application position.
  - [ ] Native code compilation

* I/O
  - [ ] Tables and structs should have read/write support
    Structs and other high-level objects may not be READ by any Arete instance, depending on code being loaded, but
    it'd still be good to have.

* Emscripten compile
  - [ ] Better demo. REPL, SDL, etc. Probably will need to write a callable C interface.

* Various optimizations that probably won't make a difference
  - [x] heap_type_equals() primitive, for when we want to check whether the type of a heap object matches a type.
