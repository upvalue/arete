rough outline of major projects, in order
- modules
- structs with inheritance, and basic methods
- syntax-rules
- compiler

runtime
- 0.25 / 9 prints different than python. difference in I/O or some kind of error?
- some symbols should most likely be immutable
- there needs to be a level of type assertion that simply prints warnings, or throws C++ exceptions if that's what the user wants
- value representation: should 0 be false?
- also, being able to initialize Values with ints is convenient for returning constants, but seems error-prone in other
  ways (e.g. occasionally trying to write off a C++ boolean as a Scheme boolean and it not being rejected by the compiler)
x figure out how to get a stack trace with C++ after assertion failures
  just use valgrind
x hash tables
- ports
- flonum 4 is printed as 4 and not 4.0
x are C++ exceptions okay to use? 
  nah
garbage collection
- default heap size should be set after memory usage is understood
- better handling of large allocations
x semispace garbage collection for extreme debugging and robustness
- could semispace collector also be used to optionally compact the incremental collector?
- how to reduce code duplication between copy & mark routines?
- finalizers
- benchmarking
interpreter
x let
  (implemented as macro)
- quote must strip boxes, and should perhaps update lists in place to reflect this (?)
x and/or
- the passing of fn_name is pretty ugly and could be achieved with an RAII-stack
- MAYBE: tail call optimization. 
- stack traces sometimes have duplicate entries
x naming lambdas
  - possibly a name-lambda function allowing the generation of named lambda for better tracebacks
x stack traces
  stack traces should include:
  + source code display (how hard?)
  x references to undefined symbols (reader should wrap with source info)
  + c-function names and source code locations
reader
- EOF in string should show where string *starts*
- improve the mismatched bracket error message
x expression comments #;
x block comments #|
- extended symbols |
- unicode
x attach source code info to symbols by boxing them
macroexpander
-
  (let-syntax () (define x #t)) x => #T

- nested renames and identifier_equal
- error messages should be super descriptive
  e.g.
  (let ((5 #t)) #t)
  should give you an error like

    Error while expanding expression (let ((5 #t)) #t)
                                           ^^^^^^
    From file.scm:34
  
    Let bindings must be names

- can crash by defining macros to bad stuff e.g.
  (define-syntax hello #t)
x explicit renaming
x check validity of lambda
- syntax-rules
language
- keywords
- get some basic demos running. closures, fibonacci, that kind of stuff
- macro expansion
- r5rs support
- r7rs support (within reason)
- consider immutable pairs like Racket
testing
- doctests makes compile times obscene, maybe utest or something?
benchmarks
- GC
- tables
cleanup
x use State::macroexpand and remove all other eval_args functionality

major projects: types, modules, structs, tables, compiler.
