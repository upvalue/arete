runtime
x figure out how to get a stack trace with C++ after assertion failures
  just use valgrind
- hash tables
- ports
- are C++ exceptions okay to use? 
garbage collection
- better handling of large allocations
x semispace garbage collection for extreme debugging and robustness
- could semispace collector also be used to optionally compact the incremental collector?
- how to reduce code duplication between copy & mark routines?
- finalizers
- benchmarking
interpreter
x let
  (implemented as macro)
- quote must strip boxes, and should perhaps update lists in place to reflect this (?)
- and/or
- the passing of fn_name is pretty ugly and could be achieved with an RAII-stack
- MAYBE: tail call optimization. 
x naming lambdas
  - possibly a name-lambda function allowing the generation of named lambda for better tracebacks
x stack traces
  stack traces should include:
  + source code display (how hard?)
  x references to undefined symbols (reader should wrap with source info)
  + c-function names and source code locations
reader
- improve the mismatched bracket error message
x expression comments #;
x block comments #|
- extended symbols |
- unicode
x attach source code info to symbols by boxing them
macroexpander
- explicit renaming
- syntax-rules
language
- get some basic demos running. closures, fibonacci, that kind of stuff
- macro expansion
- r5rs support
- r7rs support (within reason)
